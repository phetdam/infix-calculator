/**
 * @file parser.h
 * @author Derek Huang
 * @brief C++ header for the infix calculator parse driver
 * @copyright MIT License
 */

#ifndef PDCALC_PARSER_H_
#define PDCALC_PARSER_H_

#include <string>

/**
 * `parse_driver` forward declaration to satisfy the `yy::parser` definition.
 *
 * The `yy::parser` ctor takes `parse_driver&` as a parameter.
 */
namespace pdcalc { class parse_driver; }  // namespace pdcalc

/**
 * The C++ header generated by Bison defining the parsing class.
 *
 * We need this in order to use `YY_DECL`, and so this must be included first.
 */
#include "pdcalc/parser.yy.h"

/**
 * `YY_DECL` function declaration return type.
 *
 * This is defined separately so the `parser` friend declaration can use it.
 */
#define PDCALC_YYLEX_RETURN yy::parser::symbol_type

/**
 * `YY_DECL` function name.
 *
 * Usually this can be left as `yylex` unless the Flex name prefix is changed.
 */
#define PDCALC_YYLEX yylex

/**
 * `YY_DECL` function declaration arguments.
 *
 * Should be a comma-separated list of function arguments.
 */
#define PDCALC_YYLEX_ARGS pdcalc::parse_driver& driver

/**
 * Macro declaring `yylex` in the format the Bison parser expects.
 *
 * The corresponding parser handles complete symbols and uses variant values.
 */
#define YY_DECL PDCALC_YYLEX_RETURN PDCALC_YYLEX(PDCALC_YYLEX_ARGS)

/**
 * `yylex` declaration compatible with C++ Bison parser.
 *
 * There is no need to make this `extern "C"` since the generated Flex lexer
 * is being compiled as C++, not as straight C code.
 */
YY_DECL;

namespace pdcalc {

/**
 * `pdcalc` infix calculator parse driver.
 *
 * Encapsulates the Flex/Bison generated lexer + parser.
 *
 * @note This interface is highly subject to change. There is consideration
 *  being put into more of a functional interface, with this class being used
 *  instead as a kind of passive parsing context object
 */
class parse_driver {
public:

  /**
   * Parse input from `stdin` without tracing.
   */
  bool parse()
  {
    return parse("", false, false);
  }

  /**
   * Parse the specified input file.
   *
   * @param input_file File to read input from, empty or "-" for `stdin`
   * @param enable_trace `true` to enable lexer and parse tracing
   */
  bool parse(const std::string& input_file, bool enable_trace = false)
  {
    return parse(input_file, enable_trace, enable_trace);
  }

  /**
   * Parse the specified input file.
   *
   * @param input_file File to read input from, empty or "-" for `stdin`
   * @param trace_lexer `true` to enable lexer tracing
   * @param trace_parser `true` to enable parser tracing
   * @returns `true` on success, `false` on failure
   */
  bool parse(std::string input_file, bool trace_lexer, bool trace_parser)
  {
    // initialize Bison parser location for location tracking. note that the
    // parameter must be an address to a non-const std::string
    location_.initialize(&input_file);
    // perform Flex lexer setup, create Bison parser, set debug level, parse
    if (!lex_setup(input_file, trace_lexer))
      return false;
    yy::parser parser{*this};
    parser.set_debug_level(trace_parser);
    auto status = parser.parse();
    // perform Flex lexer cleanup + return
    if (!lex_cleanup(input_file))
      return false;
    // TODO: should last_error_ be set on parse failure? ideally during the
    // parsing the error should be set so it can be printed later
    return !status;
  }

  /**
   * Parse input from `stdin` without tracing.
   */
  auto operator()() { return parse(); }

  /**
   * Parse the specified input file.
   *
   * @param input_file File to read input from, empty or "-" for `stdin`
   * @param enable_trace `true` to enable lexer and parse tracing
   */
  auto operator()(const std::string& input_file, bool enable_trace = false)
  {
    return parse(input_file, enable_trace);
  }

  /**
   * Parse the specified input file.
   *
   * @param input_file File to read input from, empty or "-" for `stdin`
   * @param trace_lexer `true` to enable lexer tracing
   * @param trace_parser `true` to enable parser tracing
   * @returns `true` on success, `false` on failure
   */
  auto operator()(
    const std::string& input_file, bool trace_lexer, bool trace_parser)
  {
    return parse(input_file, trace_lexer, trace_parser);
  }

  // allow lexer to access to the parse driver members to update location +
  // error note we use (::PDCALC_YYLEX) to tell compiler PDCALC_YYLEX is in the
  // global namespace, not in the current enclosing pdcalc namespace
  friend PDCALC_YYLEX_RETURN (::PDCALC_YYLEX)(PDCALC_YYLEX_ARGS);
  // allow parser to access parse driver members to update location + error
  friend class yy::parser;

  /**
   * Return a message describing the last error that occurred.
   *
   * Errors can occur before, during, or after parsing.
   */
  const auto& last_error() const noexcept { return last_error_; }

private:
  yy::location location_;
  std::string last_error_;

  /**
   * Perform setup for the Flex lexer.
   *
   * @param input_file Input file to read. If empty or "-", `stdin` is used.
   * @param enable_debug `true` to turn on lexer tracing, default `false`
   * @returns `true` on success, `false` on failure and sets `last_error_`
   */
  bool lex_setup(const std::string& input_file, bool enable_debug) noexcept;

  /**
   * Perform cleanup for the Flex lexer.
   *
   * Currently, all this does is close `yyin` unless `yyin` is `stdin`.
   *
   * @param input_file Input file passed to `lex_setup`. Used in error reporting.
   */
  bool lex_cleanup(const std::string& input_file) noexcept;
};

}  // namespace pdcalc

#endif  // PDCALC_PARSER_H_
