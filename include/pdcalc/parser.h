/**
 * @file parser.h
 * @author Derek Huang
 * @brief C++ API header for the Bison-generated parser header
 * @copyright MIT License
 */

#ifndef PDCALC_PARSER_H_
#define PDCALC_PARSER_H_

namespace pdcalc {

class parser;

}  // namespace pdcalc

/**
 * The C++ header generated by Bison defining the parsing class.
 *
 * We need this in order to use `YY_DECL`, and so this must be included first.
 */
#include "pdcalc/parser.yy.h"

/**
 * `YY_DECL` function declaration return type.
 *
 * This is defined separately so the `parser` friend declaration can use it.
 */
#define PDCALC_YYLEX_RETURN yy::parser::symbol_type

/**
 * `YY_DECL` function name.
 *
 * Usually this can be left as `yylex` unless the Flex name prefix is changed.
 */
#define PDCALC_YYLEX yylex

/**
 * `YY_DECL` function declaration arguments.
 *
 * Should be a comma-separated list of function arguments.
 */
#define PDCALC_YYLEX_ARGS pdcalc::parser& parse_context

/**
 * Macro declaring `yylex` in the format the Bison parser expects.
 *
 * The corresponding parser handles complete symbols and uses variant values.
 */
#define YY_DECL PDCALC_YYLEX_RETURN PDCALC_YYLEX(PDCALC_YYLEX_ARGS)

/**
 * `yylex` declaration compatible with C++ Bison parser.
 *
 * @note We might make this `extern "C"` later, in which case we would not need
 *  to define all the macros we have for the `parser` friend declaration.
 */
YY_DECL;

namespace pdcalc {

class parser {
public:

  /**
   * Parse input from `stdin`.
   */
  int parse()
  {
    return parse("-", false, false);
  }

  /**
   * Parse the incoming input file.
   */
  int parse(std::string input_file, bool trace_lexer, bool trace_parser)
  {
    // initialize Bison parser location for location tracking. note that the
    // parameter must be an address to a non-const std::string
    location_.initialize(&input_file);
    // perform Flex lexer setup
    if (!lex_setup(input_file, trace_lexer))
      return 1;
    // create Bison parser, set debug level, and parse
    yy::parser parser{*this};
    parser.set_debug_level(trace_parser);
    auto status = parser.parse();
    // perform Flex lexer cleanup
    if (!lex_cleanup())
      return 1;
    return status;
  }

  // allow lexer to access to the parse driver members for location update.
  // note we use (::PDCALC_YYLEX) to tell compiler PDCALC_YYLEX is in the
  // global namespace, not in the current enclosing pdcalc namespace
  friend PDCALC_YYLEX_RETURN (::PDCALC_YYLEX)(PDCALC_YYLEX_ARGS);

private:
  /**
   * Perform setup for the Flex lexer.
   *
   * @param input_file Input file to read. If empty or "-", `stdin` is used.
   * @param enable_debug `true` to turn on lexer tracing, default `false`
   * @returns `true` on success, `false` on failure
   */
  bool lex_setup(const std::string& input_file, bool enable_debug);

  /**
   * Perform cleanup for the Flex lexer.
   *
   * Currently, all this does is close `yyin`.
   */
  bool lex_cleanup();

  yy::location location_;
};

}  // namespace pdcalc

#endif  // PDCALC_PARSER_H_
